import { Duration, Lazy } from 'aws-cdk-lib';
import { Construct, IConstruct } from 'constructs';
import { AlertManagerConfiguration } from './configuration';
import { AlertManagerMatcher } from './matcher';
import { AlertManagerReceiver } from './receiver';
import { TimeInterval } from './time-interval';


/**
 * Configuration for the alert manager route.
 */
export interface AlertManagerRouteProps {
  /**
   * Times when the route should be active. An empty value means that the route
   * is always active. Additionally, the root node cannot have any active
   * times.
   *
   * The route will send notifications only when active, but otherwise acts
   * normally (including ending the route-matching process if the
   * `continueMatching` option is not set).
   */
  readonly activeTimeIntervals?: TimeInterval[];

  /**
   * Optional child routes to add to the node.
   */
  readonly children?: AlertManagerRoute[];

  /**
   * Whether an alert should continue matching subsequent sibling nodes.
   */
  readonly continueMatching?: boolean;

  /**
   * The labels by which incoming alerts are grouped together. For example,
   * multiple alerts coming in for cluster=A and alertname=LatencyHigh would be
   * batched into a single group.
   */
  readonly groupByLabels?: string[];

  /**
   * How long to wait before sending a notification about new alerts that are
   * added to a group of alerts for which an initial notification has already
   * been sent (usually ~5m or more).
   */
  readonly groupInterval?: Duration;

  /**
   * How long to initially wait to send a notification for a group of alerts.
   * Allows to wait for an inhibiting alert to arrive or collect more initial
   * alerts for the same group (usually ~0s to few minutes).
   */
  readonly groupWait?: Duration;

  /**
   * A list of matchers that an alert has to fulfill to match the node.
   */
  readonly matchers?: AlertManagerMatcher[];

  /**
   * Times when the route should be muted. The root node cannot have any mute
   * times.
   *
   * When a route is muted it will not send any notifications, but otherwise
   * acts normally (including ending the route-matching process if the
   * `continueMatching` option is not set).
   */
  readonly muteTimeInterval?: TimeInterval[];

  /**
   * The receiver that should be the target of alerts that are generated by the
   * node.
   */
  readonly receiver: AlertManagerReceiver;

  /**
   * How long to wait before sending a notification again if it has already
   * been sent successfully for an alert. (Usually ~3h or more).
   */
  readonly repeatInterval?: Duration;
}

/**
 * Defines a node in a routing tree and its children. Its optional
 * configuration parameters are inherited from its parent node if not set.
 *
 * Every alert enters the routing tree at the configured top-level route, which
 * must match all alerts (i.e. not have any configured matchers). It then
 * traverses the child nodes. If `continueMatching` is set to `false`, it stops
 * after the first matching child. If `continueMatching` is `true` on a
 * matching node, the alert will continue matching against subsequent siblings.
 * If an alert does not match any children of a node (no matching child nodes,
 * or none exist), the alert is handled based on the configuration parameters
 * of the current node.
 *
 * @see [Route Official Documentation](https://prometheus.io/docs/alerting/latest/configuration/#route)
 */
export class AlertManagerRoute extends Construct {
  /**
   * Internal collection of times when the route should be active. An empty
   * value means that the route is always active. Additionally, the root node
   * cannot have any active times.
   */
  private readonly _activeTimeIntervals: TimeInterval[];

  /**
   * IUnternal collection of child routes to add to the node.
   */
  private readonly _children: AlertManagerRoute[];

  /**
   * Internal collection of labels by which incoming alerts are grouped
   * together.
   */
  private readonly _groupByLabels: string[];

  /**
   * Interncal collection of matchers that an alert has to fulfill to match the
   * node.
   */
  private readonly _matchers: AlertManagerMatcher[];

  /**
   * Internal collection of times when the route should be muted. The root node
   * cannot have any mute times.
   */
  private readonly _muteTimeIntervals: TimeInterval[];

  /**
   * Whether an alert should continue matching subsequent sibling nodes.
   *
   * @group Inputs
   */
  public readonly continueMatching?: boolean;

  /**
   * How long to wait before sending a notification about new alerts that are
   * added to a group of alerts for which an initial notification has already
   * been sent (usually ~5m or more).
   *
   * @group Inputs
   */
  public readonly groupInterval?: Duration;

  /**
   * How long to initially wait to send a notification for a group of alerts.
   * Allows to wait for an inhibiting alert to arrive or collect more initial
   * alerts for the same group (usually ~0s to few minutes).
   *
   * @group Inputs
   */
  public readonly groupWait?: Duration;

  /**
   * The receiver that should be the target of alerts that are generated by the
   * node.
   *
   * @group Inputs
   */
  public readonly receiver: AlertManagerReceiver;

  /**
   * How long to wait before sending a notification again if it has already
   * been sent successfully for an alert. (Usually ~3h or more).
   *
   * @group Inputs
   */
  public readonly repeatInterval?: Duration;

  /**
   * Times when the route should be active. An empty value means that the route
   * is always active. Additionally, the root node cannot have any active
   * times.
   *
   * The route will send notifications only when active, but otherwise acts
   * normally (including ending the route-matching process if the
   * `continueMatching` option is not set).
   *
   * @group Inputs
   */
  public get activeTimeIntervals(): TimeInterval[] {
    return [...this._activeTimeIntervals];
  }

  /**
   * Optional child routes to add to the node.
   *
   * @group Inputs
   */
  public get children(): AlertManagerRoute[] {
    return [...this._children];
  }

  /**
   * The labels by which incoming alerts are grouped together. For example,
   * multiple alerts coming in for cluster=A and alertname=LatencyHigh would be
   * batched into a single group.
   *
   * @group Inputs
   */
  public get groupByLabels(): string[] {
    return [...this._groupByLabels];
  }

  /**
   * A list of matchers that an alert has to fulfill to match the node.
   *
   * @group Inputs
   */
  public get matchers(): AlertManagerMatcher[] {
    return [...this._matchers];
  }

  /**
   * Times when the route should be muted. The root node cannot have any mute
   * times.
   *
   * When a route is muted it will not send any notifications, but otherwise
   * acts normally (including ending the route-matching process if the
   * `continueMatching` option is not set).
   *
   * @group Inputs
   */
  public get muteTimeIntervals(): TimeInterval[] {
    return [...this._muteTimeIntervals];
  }


  /**
   * Creates a new instance of the AlertManagerRoute class.
   *
   * @param scope A CDK Construct that will serve as this construct's parent in
   * the construct tree.
   * @param id A name to be associated with the stack and used in resource
   * naming. Must be unique within the context of 'scope'.
   * @param options Arguments related to the configuration of this construct.
   */
  public constructor(scope: AlertManagerConfiguration | AlertManagerRoute, id: string, options: AlertManagerRouteProps) {
    super(scope, id);

    this._activeTimeIntervals = [];
    this._children = [];
    this._groupByLabels = [];
    this._matchers = [];
    this._muteTimeIntervals = [];

    this.continueMatching = options.continueMatching;
    this.groupInterval = options.groupInterval;
    this.groupWait = options.groupWait;
    this.receiver = options.receiver;
    this.repeatInterval = options.repeatInterval;

    options.activeTimeIntervals?.forEach((x) => {
      this.addMuteTimeInterval(x);
    });

    options.children?.forEach((x) => {
      this.addChild(x);
    });

    options.groupByLabels?.forEach((x) => {
      this.addGroupByLabel(x);
    });

    options.matchers?.forEach((x) => {
      this.addMatcher(x);
    });

    options.muteTimeInterval?.forEach((x) => {
      this.addMuteTimeInterval(x);
    });
  }

  /**
   * Adds a new time when the route should be active. The root node cannot have
   * any active times.
   *
   * The route will send notifications only when active, but otherwise acts
   * normally (including ending the route-matching process if the
   * `continueMatching` option is not set).
   *
   * @param interval The time interval when alerting on this route should be
   * active.
   * @returns The route where the interval was associated.
   */
  public addActiveTimeInterval(interval: TimeInterval): AlertManagerRoute {
    this._activeTimeIntervals.push(interval);
    return this;
  }

  /**
   * Adds a new child route to this node.
   *
   * @param child The child node to associate.
   * @returns The route where the child was associated.
   */
  public addChild(child: AlertManagerRoute): AlertManagerRoute {
    this._children.push(child);
    return this;
  }

  /**
   * Adds a label by which incoming alerts are grouped together. For example,
   * multiple alerts coming in for cluster=A and alertname=LatencyHigh would be
   * batched into a single group.
   *
   * @param label The label by which incoming alerts should be grouped.
   * @returns The route where the label was associated.
   */
  public addGroupByLabel(label: string): AlertManagerRoute {
    this._groupByLabels.push(label);
    return this;
  }

  /**
   * Adds a matcher that an alert has to fulfill to match the node.
   *
   * @param matcher The matcher to associate.
   * @returns The route where the matcher was associated.
   */
  public addMatcher(matcher: AlertManagerMatcher): AlertManagerRoute {
    this._matchers.push(matcher);
    return this;
  }

  /**
   * Adds a time when the route should be muted. The root node cannot have any
   * mute times.
   *
   * When a route is muted it will not send any notifications, but otherwise
   * acts normally (including ending the route-matching process if the
   * `continueMatching` option is not set).
   *
   * @param interval
   * @returns
   */
  public addMuteTimeInterval(interval: TimeInterval): AlertManagerRoute {
    this._muteTimeIntervals.push(interval);
    return this;
  }

  /**
   * Associates the route with a construct that is handling the configuration
   * of alert manager that will consume the configuration.
   *
   * @param scope The construct handling the configuration of alert manager
   * that will consume the rendered configuration.
   * @returns An alert manager `route` configuration object.
   */
  public bind(scope: IConstruct): { [key: string]: any } {
    return {
      active_time_intervals: Lazy.list(
        {
          produce: () => {
            return this._activeTimeIntervals.map((x) => {
              return x.name;
            });
          },
        },
        {
          omitEmpty: true,
        },
      ),
      continue: this.continueMatching,
      group_by: Lazy.list(
        {
          produce: () => {
            return this._groupByLabels;
          },
        },
        {
          omitEmpty: true,
        },
      ),
      group_intervalL: this.groupInterval ? `${this.groupInterval.toSeconds()}s` : undefined,
      group_wait: this.groupWait ? `${this.groupWait.toSeconds()}s` : undefined,
      matchers: Lazy.list(
        {
          produce: () => {
            return this._matchers.map((x) => {
              return x.expression;
            });
          },
        },
        {
          omitEmpty: true,
        },
      ),
      mute_time_intervals: Lazy.list(
        {
          produce: () => {
            return this._muteTimeIntervals.map((x) => {
              return x.name;
            });
          },
        },
        {
          omitEmpty: true,
        },
      ),
      receiver: this.receiver.name,
      repeat_interval: this.repeatInterval ? `${this.repeatInterval.toSeconds()}s` : undefined,
      routes: Lazy.any(
        {
          produce: () => {
            return this._children.map((x) => {
              return x.bind(scope);
            });
          },
        },
        {
          omitEmptyArray: true,
        },
      ),
    };
  }
}